"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.BorderTransformer = void 0;
var transformer_1 = require("./transformer");
var table_1 = require("../../models/table");
var BorderTransformer = /** @class */ (function (_super) {
    __extends(BorderTransformer, _super);
    function BorderTransformer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BorderTransformer.prototype.transform = function (input) {
        if (input == null || input.isEmpty())
            return input;
        var hasLeftBorder = this.isColumnEmpty(input.rows, 0);
        var hasRightBorder = this.isColumnEmpty(input.rows, input.columnCount - 1);
        var rows = this.rowsWithoutEmptyFirstAndLastColumn(input.rows, hasLeftBorder, hasRightBorder);
        var alignments = this.alignmentsWithoutEmptyFirstAndLastColumn(input.alignments, hasLeftBorder, hasRightBorder);
        var leftPad = hasLeftBorder
            ? input.leftPad
            : "";
        var result = new table_1.Table(rows, input.separatorEOL, alignments, leftPad);
        result.hasLeftBorder = hasLeftBorder;
        result.hasRightBorder = this.hasRightBorder(hasLeftBorder, hasRightBorder);
        return result;
    };
    BorderTransformer.prototype.isColumnEmpty = function (rows, column) {
        for (var row = 0; row < rows.length; row++) {
            var value = rows[row].cells[column];
            if (value != null && value.getValue().trim() != "")
                return false;
        }
        return true;
    };
    BorderTransformer.prototype.rowsWithoutEmptyFirstAndLastColumn = function (rows, hasLeftBorder, hasRightBorder) {
        var newRows = rows;
        if (hasLeftBorder)
            this.removeColumn(newRows, 0);
        if (hasRightBorder)
            this.removeColumn(newRows, newRows[0].cells.length - 1);
        return newRows;
    };
    BorderTransformer.prototype.removeColumn = function (rows, column) {
        for (var row = 0; row < rows.length; row++)
            rows[row].cells.splice(column, 1);
    };
    BorderTransformer.prototype.alignmentsWithoutEmptyFirstAndLastColumn = function (alignments, hasLeftBorder, hasRightBorder) {
        var newAlignments = alignments;
        if (hasLeftBorder)
            newAlignments.shift();
        if (hasRightBorder)
            newAlignments.pop();
        return newAlignments;
    };
    BorderTransformer.prototype.hasRightBorder = function (hadLeftBorder, hadRightBorder) {
        var result = hadRightBorder;
        if (hadLeftBorder && !hadRightBorder)
            result = true;
        if (!hadLeftBorder && hadRightBorder)
            result = false;
        return result;
    };
    return BorderTransformer;
}(transformer_1.Transformer));
exports.BorderTransformer = BorderTransformer;
