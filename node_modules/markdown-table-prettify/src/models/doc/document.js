"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Document = void 0;
var line_1 = require("./line");
var range_1 = require("./range");
var Document = /** @class */ (function () {
    function Document(text) {
        this._lines = this.buildLines(text);
    }
    Object.defineProperty(Document.prototype, "lines", {
        get: function () {
            return this._lines;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Document.prototype, "fullRange", {
        get: function () {
            return new range_1.Range(0, this._lines.length);
        },
        enumerable: false,
        configurable: true
    });
    Document.prototype.getLines = function (range) {
        return range == null
            ? this.lines
            : this.lines.slice(range.startLine, range.endLine + 1);
    };
    Document.prototype.getText = function (range) {
        if (range === void 0) { range = null; }
        var lines = this.getLines(range);
        return lines.reduce(function (acc, curr, index) {
            // avoid adding the line break for the last line for range selections
            var eol = range != null && index == lines.length - 1
                ? ""
                : curr.EOL;
            return acc += curr.value + eol;
        }, "");
    };
    Document.prototype.replaceTextInRange = function (range, newText) {
        var newLines = this.buildLines(newText);
        if (range.endLine - range.startLine + 1 !== newLines.length) {
            throw new Error("Unexpected range length of text to replace.");
        }
        // preserve the EOL of the last line, as the newText does not have it
        newLines[newLines.length - 1].EOL = this.lines[range.endLine].EOL;
        for (var i = range.startLine; i <= range.endLine; i++) {
            this.lines[i] = newLines[i - range.startLine];
        }
    };
    Document.prototype.buildLines = function (text) {
        return (text.match(/[^\n]*\n|[^\n]+/g) || [""]).map(function (row) { return new line_1.Line(row); });
    };
    return Document;
}());
exports.Document = Document;
